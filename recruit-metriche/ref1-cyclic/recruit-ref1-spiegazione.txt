Dire che questo cyclic comprendeva un altro cyclic, e sono stati rimossi insieme

Strategia e implementazione del refactoring per la risoluzione della Cyclic Dependency
Identificazione iniziale della problematica
Durante l’analisi statica effettuata con lo strumento Arcan, è stato evidenziato uno smell di tipo Cyclic Dependency, riguardante tre package del progetto:

com.stalary.pf.recruit.data.entity

com.stalary.pf.recruit.data.dto

com.stalary.pf.recruit.data.vo

Questi tre package rappresentano rispettivamente:

Entity: contenenti le entità persistenti del dominio applicativo (annotate tipicamente con JPA).

DTO (Data Transfer Object): oggetti utilizzati principalmente per trasferire dati tra differenti strati applicativi (ad esempio tra il servizio e il client REST).

VO (View Object): oggetti di presentazione, utilizzati per adattare i dati alle specifiche esigenze del layer di presentazione.

La presenza del ciclo era dovuta a dipendenze incrociate, ossia:

il package entity importava direttamente classi dal package dto.

il package dto importava classi dal package vo.

il package vo, a sua volta, importava classi dal package entity.

Questo ciclo, generando una mutua dipendenza fra layer logicamente separati, comprometteva la chiarezza, la manutenibilità e l'estendibilità della struttura architetturale del progetto.

Analisi del ciclo e scelte di design
Dopo aver analizzato nel dettaglio le classi coinvolte e le motivazioni delle reciproche dipendenze, sono state proposte diverse strategie di refactoring:

Introduzione di mapper espliciti:
Creare un package separato mapper dedicato esclusivamente alle operazioni di conversione tra classi appartenenti a package differenti (ad esempio da VO a DTO o da Entity a DTO). Questo avrebbe consentito di centralizzare la logica di trasformazione, evitando dipendenze dirette fra package logicamente distanti.

Creazione di un modulo comune (common):
Identificare classi trasversalmente utilizzate in più package e inserirle in un modulo comune, per rompere le dipendenze circolari.

Ridefinizione del contenuto dei package:
Chiarire meglio la responsabilità dei package coinvolti, garantendo una separazione più netta fra "domain model", "transfer objects" e "view objects".

Tra queste opzioni, è stato scelto di combinare principalmente due strategie:

Mapper espliciti: per eliminare le conversioni dirette fra VO e DTO.

Modulo comune: per condividere classi utilizzate trasversalmente da DTO e Entity.

Implementazione dettagliata del refactoring
Primo intervento: Rimozione della dipendenza tra DTO e VO
La prima dipendenza affrontata riguardava una classe User (DTO) che importava direttamente la classe HR dal package vo. Per risolvere questa dipendenza, è stato applicato il seguente refactoring:

Il costruttore del DTO User, che dipendeva direttamente dal VO HR, è stato rimosso dalla classe User stessa.

È stato creato un mapper esterno nel nuovo package mapper, contenente un metodo specifico che costruisce un oggetto User (DTO) partendo da un oggetto HR (VO).

Così facendo, il DTO non dipende più direttamente dal VO, ma solo il mapper ha questa responsabilità di trasformazione. Questo ha permesso di spezzare il primo anello del ciclo.

Secondo intervento: Estrazione degli aggregatori VO-Entity
È stato poi riscontrato un secondo problema: alcune classi VO (come RecruitAndHrAndCompany e RecruitAndCompany) importavano direttamente classi Entity (RecruitEntity, CompanyEntity). Questo uso diretto delle Entity dal package vo contribuiva ulteriormente al ciclo, dal momento che il package delle entità rappresenta un dominio isolato che non dovrebbe essere direttamente esposto allo strato di presentazione.

Per risolvere questa situazione:

Gli aggregatori (RecruitAndHrAndCompany, RecruitAndCompany) sono stati spostati dal package vo in un nuovo package mapper. In questo modo, il package vo non importa più direttamente classi dal package entity.

Questo spostamento ha consentito di preservare la responsabilità logica degli oggetti VO (presentazione pura), evitando contaminazioni dal dominio applicativo.

Terzo intervento: Creazione del modulo comune (common)
Infine, si è manifestato un ulteriore ciclo dovuto all’utilizzo diretto di una classe DTO (SkillRule) all’interno di una Entity (RecruitEntity). Poiché un'Entity non dovrebbe dipendere da classi appartenenti ai DTO (logicamente superiori nel flusso applicativo), è stato deciso di introdurre un modulo comune:

È stato creato il nuovo package common, contenente la classe SkillRule, condivisa sia da Entity che da DTO.

Questo intervento ha fatto sì che le Entity non dipendessero più direttamente da classi DTO, ma esclusivamente da classi appartenenti a questo nuovo modulo condiviso (common), collocato in una posizione neutrale rispetto ai vari layer architetturali.

Verifica della soluzione adottata
Dopo aver completato questi interventi, è stata effettuata una nuova analisi con lo strumento Arcan, che ha confermato la risoluzione definitiva della Cyclic Dependency. Il risultato finale è un'architettura con una struttura gerarchica delle dipendenze più chiara, così sintetizzata:

Il package delle entità dipende unicamente dal modulo comune.

Il package dei DTO dipende unicamente dal modulo comune.

Il package dei VO dipende dai DTO esclusivamente tramite mapper intermedi e non contiene più riferimenti diretti alle entità.

I mapper, infine, dipendono da entità, DTO e VO, ma senza generare cicli grazie alla loro collocazione dedicata.

In definitiva, la soluzione proposta risulta efficace nell’eliminare la Cyclic Dependency, favorisce una migliore leggibilità e manutenibilità del codice, e permette un più semplice futuro sviluppo del progetto, essendo adesso ogni strato architetturale isolato, testabile indipendentemente e coerente con le proprie responsabilità.