Contesto e motivazione
Nei microservizi del progetto si erano accumulate copie multiple delle stesse classi di wrapper di risposta (ResponseMessage) e dei relativi codici di errore (ResultEnum), presenti in package diversi (data.dto, data.vo, dto, vo). Questa frammentazione generava inevitabilmente:

Duplicazioni di implementazione identica, con costi di manutenzione elevati;

Incoerenze semantiche tra servizi (messaggi di errore o formati leggermente diversi);

Rischio di drift nel tempo, quando una modifica veniva applicata a un servizio ma non agli altri.

Obiettivo
Centralizzare queste classi comuni in un unico artefatto di libreria (pf-common) per garantire:

Single Source of Truth: un’unica definizione di ResponseMessage e ResultEnum;

Coerenza e uniformità delle risposte API;

Riduzione del technical debt dovuto al code cloning.

Soluzione proposta

Creazione del modulo Maven/Gradle pf-common

Packaging JAR, privo di controller o logica runtime.

Package base com.stalary.pf.common, con due sottopackage (es. vo ed exception) se necessario.

Spostamento delle classi duplicate

ResponseMessage<T> e ResultEnum vengono tagliate da ciascun microservizio e incollate in pf-common.

Eliminazione delle versioni locali residue.

Aggiornamento delle dipendenze

Ogni microservizio aggiunge una dipendenza su pf-common nel proprio pom.xml/build.gradle.

Gli import vengono uniformati a com.stalary.pf.common.vo.ResponseMessage e com.stalary.pf.common.exception.ResultEnum.

Implementazione e governance

Scope ristretto: in common risiedono solo le due classi condivise, evitando di trasformarlo in un “hub” troppo pesante.

Semantic Versioning: patch per correzioni di bug, minor per aggiunta di codici di errore non-breaking, major per cambiamenti incompatibili.

Review centralizzata: ogni modifica a common richiede approvazione per evitare bloat e regressioni nei consumer.

Vantaggi ottenuti

Manutenibilità: una sola modifica, un solo punto di deploy;

Coesione: common resta essenziale e dedicato a tipi dati puri;

Decoupling: i microservizi consumano common, ma common non dipende da loro;

Qualità del codice: nessun duplicate code, nessun ciclo di dipendenza, maggiore sicurezza di tipo.

Conclusione
L’estrazione delle classi duplicate in un modulo common rappresenta una best practice architetturale: migliora la qualità dei microservizi, riduce il rischio di errori e semplifica l’evoluzione futura, mantenendo un’architettura modulare, coesa e facilmente versionabile.