Ho deciso di risolvere il cyclic su com.regent.rpush.route.handler, com.regent.rpush.route.utils perché venivano coinvolte classi che rientravano in altri cyclic, quindi mi aspetto che risolvendo quest smell io ne risolva automaticamente altri.

Abstract
In questo lavoro si illustra l’intervento di rifattorizzazione volto a eliminare tre dipendenze cicliche riscontrate tra i componenti del modulo di routing del sistema RPush. Partendo da una situazione iniziale caratterizzata da nove code smells, tre dei quali relativi a dipendenze circolari (cyclic dependency), si è applicato il principio di Inversione delle Dipendenze (DIP) per riorganizzare i package e ridurre la complessità dei legami tra classi. Al termine dell’intervento, il numero di smells è sceso a sei, con la completa rimozione dei tre cicli.

1. Introduzione
Le dipendenze cicliche tra componenti di un sistema rappresentano un segnale di scarsa manutenibilità e incidono negativamente su extensibility e testabilità. Nel contesto del progetto RPush, lo strumento di analisi Arcan ha evidenziato tre cicli di dipendenza all’interno dei package route.handler e route.utils, compromettendo il rispetto dei principi SOLID e, in particolare, il principio di Inversione delle Dipendenze.

2. Analisi del problema
Le principali classi coinvolte — MessageHandler (nel package route.handler) e MessageHandlerUtils insieme a MessageHandlerHolder (nel package route.utils) — importavano reciprocamente elementi l’una dall’altra, generando un ciclo:

MessageHandler utilizzava le utility statiche di MessageHandlerUtils per riflettere sul tipo generico di messaggio da gestire.

MessageHandlerUtils e MessageHandlerHolder si appoggiavano direttamente alla classe astratta MessageHandler, per estrarre metadata e registrare gli handler.

Questa struttura violava il principio DIP, in quanto il codice di alto livello (utils) dipendeva da implementazioni di basso livello (handler) anziché da astrazioni.

3. Proposta di soluzione
Per spezzare i legami ciclici è stata introdotta una interfaccia di contratto, IMessageHandlerDescriptor, collocata in un package route.spi indipendente. Questa interfaccia esponeva soltanto:

Il tipo di messaggio gestito (messageType()),

Il tipo payload associato (payloadType()).

Tutti i MessageHandler<T> sono stati modificati per implementare quest’interfaccia anziché legarsi direttamente alle utility. A loro volta:

MessageHandlerUtils ha smesso di importare MessageHandler, lavorando unicamente su IMessageHandlerDescriptor per estrarre parametri, configurazioni e schemi.

MessageHandlerHolder è stato aggiornato per raccogliere bean IMessageHandlerDescriptor dal contesto Spring, anziché bean di tipo concreto MessageHandler.

 Implementazione
Estrazione dell’interfaccia
Adattamento di MessageHandler 
Rifattorizzazione di MessageHandlerUtils
Aggiornamento di MessageHandlerHolder

 Risultati ed effetti
Ciclo spezzato: il package di utilità non dipende più dal package dei handler concreti, ma unicamente dall’astrazione spi.

Smells rimossi: i tre cicli di dipendenza individuati da Arcan sono stati eliminati, riducendo da 9 a 6 code smells complessivi.

Migliore testabilità: grazie all’uso dell’interfaccia, è ora semplice simulare i handler nelle suite di unit test.

Estensibilità: l’aggiunta di nuovi handler richiede soltanto l’implementazione di IMessageHandlerDescriptor, senza modifiche alle utility o al registry.

6. Conclusioni
L’applicazione del principio di Inversione delle Dipendenze, mediata dall’introduzione di un’interfaccia spi, ha permesso di eliminare tre cicli di dipendenza, migliorando la modularità e la manutenibilità del codice. Il pattern utilizzato costituisce una best practice replicabile in altri contesti in cui classi di alto livello rischiano di dipendere da implementazioni concrete, compromettendo l’equilibrio architetturale del sistema.
