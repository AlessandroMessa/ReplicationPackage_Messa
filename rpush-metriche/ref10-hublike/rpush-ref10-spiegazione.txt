1. Contesto e obiettivo
Nel codice originale, la classe SocketSessionHolder si comportava come un vero e proprio “hub”: raccoglieva in sé la gestione delle sessioni in memoria, la creazione degli oggetti SocketSessionImpl, l’interazione diretta con il servizio remoto per il login/offline e la risoluzione dei bean Spring tramite SpringBeanFactory. Questo pattern genera un elevato technical debt perché:

Violazione del Single Responsibility Principle (SRP): la classe ha troppe responsabilità.

Difficoltà di testabilità e di evoluzione: per modificarne o provarne una singola parte bisogna caricare e istanziare tutto l’insieme.

Accoppiamento forte: dipende da DTO, service, factory e mappe interne, rendendo arduo sostituire o estendere una singola funzionalità.

2. Approccio di refactoring
Seguendo le linee guida di Arcan (in particolare gli estratti “Extract Class/Interface” e “Replace Service Locator with Dependency Injection”), abbiamo scomposto la classe in sei componenti distinti, ognuno con una singola responsabilità:

SessionRegistry + InMemorySessionRegistry

Responsabilità: gestire esclusivamente le mappe in-memory (client ↔ sessione, registrationId ↔ sessione).

Vantaggio: nasconde i dettagli dell’archiviazione e rende l’accesso alle sessioni un servizio dedicato e configurabile.

SessionFactory + DefaultSessionFactory

Responsabilità: incapsulare la creazione delle istanze SocketSessionImpl.

Vantaggio: separa la logica di istanziazione, permettendo di introdurre in futuro strategie alternative (es. pool, proxy, mock).

SessionLifecycleService

Responsabilità: orchestrare il login e l’offline verso RpushServerOnlineService, costruendo i LoginDTO/OfflineDTO.

Vantaggio: elimina l’uso di SpringBeanFactory (Service Locator) e centralizza la logica di persistenza dello stato, facilitando test e manutenzione.

SocketSessionService

Responsabilità: alto livello di orchestrazione: unisce registry, factory e lifecycle in metodi comodi (getOrCreate, login, offlineByClient, offlineByRegistrationId).

Vantaggio: punto unico di consumo via DI per controller/handler WebSocket, semplificando l’iniezione e la sostituzione del comportamento.

SocketSession (interfaccia)

Responsabilità: definire il contratto di una sessione (client, registrationId, attributi).

Vantaggio: consente di operare su astrazioni, non sull’implementazione concreta, migliorando la decoupling.

SocketSessionImpl

Responsabilità: implementazione concreta di SocketSession, con mappa di attributi e gestione del client.

Vantaggio: separa l’interfaccia dalla logica di memorizzazione interna.

3. Benefici ottenuti

Cohesion: ogni classe è responsabile di un solo aspetto, riducendo la complessità cognitiva.

Loose Coupling: le dipendenze avvengono tramite DI, non più via locator, e ogni componente dipende solo da ciò che gli serve.

Testabilità: si possono mockare facilmente SessionRegistry, SessionFactory o SessionLifecycleService nei test unitari.

Estendibilità: per nuovi requisiti (es. persistenza su database, logging differente, caching distribuito) basterà sostituire o aggiungere implementazioni senza toccare l’intero flusso.

Manutenibilità: bug o ottimizzazioni locali in una classe non impattano il resto del sistema.

4. Conclusione
La scomposizione in sei componenti risolve l’architectural smell da “hub-like” a un’architettura modulare, allineata ai principi SOLID e alle best practice di refactoring. Questo approccio riduce il technical debt e prepara il progetto a future evoluzioni con un impatto minimo sui consumatori dell’API.


Ecco un breve riassunto dell’ultimo refactoring:

Problema
SocketSessionService aveva tre responsabilità:

Recupero/creazione di sessioni

Gestione del login (registrationId + stato online)

Gestione della disconnessione (stato offline + chiusura client)

Soluzione
L’abbiamo divisa in tre servizi distinti, ciascuno con SRP puro:

SessionRetrievalService
• Solo metodi getOrCreate(RpushClient) e getByRegistrationId(Long).
• Dipende unicamente da SessionRegistry.

SessionAuthenticationService
• Metodo login(Long, RpushClient): crea o recupera la sessione, registra l’ID e richiama il servizio di persistenza online.
• Dipende da SessionRetrievalService, SessionRegistry e SessionLifecycleService.

SessionDisconnectionService
• Metodi disconnectByClient(RpushClient) e disconnectByRegistrationId(Long): invocano il lifecycle offline, rimuovono la sessione, chiudono il client e restituiscono l’ID.
• Dipende da SessionRetrievalService, SessionRegistry e SessionLifecycleService.

Vantaggi

Single Responsibility per ciascun service

Testabilità semplificata: ogni service è mockable e testabile in isolamento

Estendibilità: modifiche al login o alla disconnessione non impattano gli altri

Chiarezza: il flusso di ogni operazione è racchiuso in un’unica classe dedicata

Con questo ultimo step, ogni componente del modulo socket ha un’unica responsabilità, il codice è modulare, manutenibile e pronto per futuri cambiamenti.
Fine del refactoring!