Ho deciso di attaccare lo smell su: com.regent.rpush.route.service.config.query.IRpushConfigQueryService
Questo perchè avevo lo smell anche su com.regent.rpush.route.service ed ho pensato che questo fosse il modo più ordinato per iniziare a ridurlo.
In sostanza ho spezzettato la classe e la sua impl, poi ho aggiornato le dipendenze. con un analisi in itinere di arcan ho risolto lo smell ma aggiunto un unstable su uno dei sotto package. Quindi ho dovuto applicare DIP per risolverlo.
Lo smell su com.regent.rpush.route.service ha abbassato il suo TD ma non ha diminuito il size


1. Introduzione
Nell’ambito del progetto RPush, l’interfaccia IRpushConfigQueryService era diventata un “mega‐hub” (Architectural Smell: Hub-Like Dependency), accorpando batch query, default query e paginazione in un’unica API. Lo scopo del refactoring è stato ridurre il technical debt, migliorare la coesione e rispettare i principi SOLID, in particolare il Principio di Segregazione dell’Interfaccia (ISP) e il Principio di Inversione delle Dipendenze (DIP).

2. Analisi del problema
Interfaccia “tutto-fare”: esponeva più responsabilità (queryConfig, queryConfigOrDefault, pageConfig), forzando tutti i client a dipendere da metodi non utilizzati.

Coupling elevato: i client subivano un’interfaccia troppo ampia.

Instability: in una delle sotto‐implementazioni (page query) sono emerse dipendenze dirette verso utility statiche di sessione e mapping DTO, violando il layering e creando un “unstable dependency”.

3. Strategia di refactoring
Extract Interface

Rimossi i metodi CRUD non usati.

Definite tre interfacce specializzate, ciascuna con una sola responsabilità:

RpushConfigBatchQueryService → queryConfig(...)

RpushConfigDefaultQueryService → queryConfigOrDefault(...)

RpushConfigPageQueryService → pageConfig(...)

Implementazioni separate

Creazione di un bean @Service per ciascuna interfaccia, in package …query.batch.impl, …query.default.impl e …query.page.impl.

Iniezione incrociata: le classi Default e Page ricevono solo il batch service come dipendenza, evitando cicli.

Facade di transizione

IRpushConfigQueryService mantenuta solo per retro-compatibilità, trasformata in interfaccia vuota che estende le tre sub-interfacce.

Dependency Inversion Principle (DIP)

Nel package …query.page.api estratte astrazioni di dominio (ClientContext, ConfigFieldProvider) al posto delle dipendenze dirette a SessionUtils e MessageHandlerUtils.

Implementati adapter Spring (SessionClientContext in …route.adapter) che traducono chiamate ai metodi statici nelle astrazioni di servizio.

In questo modo il layer di business dipende solo dalle interfacce “stabili” e non più dalle utility statiche.

4. Risultati ottenuti
Coupling ridotto: ogni consumer inietta solo il service di cui ha realmente bisogno.

Maggiore coesione: le interfacce sono ora mono-responsabilità.

Layering corretto: il service layer non dipende più da package di utilità; le dipendenze sono state isolate tramite astrazioni e adapter.

Testabilità migliorata: Service e Adapter possono essere mockati singolarmente.

5. Conclusioni
Applicando Extract Interface e il Dependency Inversion Principle abbiamo eliminato sia l’Architectural Smell dello “hub-like dependency” sia la “unstable dependency” verso le utility. La codebase risulta ora più modulare, manutenibile e allineata alle best practice di refactoring di Arcan.
