Stesso ragionamento di ref8. Provo ref qui così sono più isolato.
Arcan-mid_late mostra come io abbia spostato lo smell dentro ad un sotto package.
però lo smell su _service non c'è più.
Se riesco a risolvere lo smell su _crud sono messo bene.

Contesto e problema
Nei moduli RpushTemplateServiceImpl e RpushTemplateReceiverGroupServiceImpl si stava manifestando un elevato fan-out dovuto alla dipendenza diretta dall’implementazione CRUD (IRpushTemplateReceiverCrudServiceImpl). Tale implementazione, oltre a gestire le operazioni di persistenza con MyBatis-Plus e Qw, incorporava logiche di validazione (SessionUtils, MessagePlatformEnum) e quindi introduceva un “nodo centrale” troppo “pesante” in termini di dipendenze.

Obiettivo di refactoring
L’obiettivo era ridurre il fan-out e applicare il Dependency Inversion Principle: far dipendere i servizi di alto livello da un’astrazione minimale, confinandone il grado di consapevolezza sulle tecnologie di persistenza e sulle utility di supporto.

Soluzione adottata
Definizione di un’API pulita
Abbiamo creato l’interfaccia IRpushTemplateReceiverService in package …service.template.api, esponendo solo i metodi necessari:

updateReceiver(RpushTemplateReceiver receiver)

deleteReceiver(Long id)

listReceiversByClient(String clientId)

listReceiversByGroup(Long groupId)

Implementazione Facade/Adapter
In …service.template.facade, la classe RpushTemplateReceiverServiceImpl delega tutte le chiamate all’IRpushTemplateReceiverCrudService esistente, ma incapsula al proprio interno la costruzione dei QueryWrapper e la chiamata ai metodi list, isolando il resto dell’applicazione dalla complessità di Qw e SessionUtils.

Refactoring dei consumer
Nei servizi RpushTemplateServiceImpl e RpushTemplateReceiverGroupServiceImpl si è sostituita l’iniezione di IRpushTemplateReceiverCrudServiceImpl con l’astrazione IRpushTemplateReceiverService. I metodi originali che utilizzavano direttamente list(Qw…) sono stati aggiornati per chiamare invece listReceiversByClient o listReceiversByGroup.

Risultati e benefici
Riduzione del fan-out: ogni servizio consumer dipende ora da un’unica interfaccia minimale, anziché dall’implementazione completa.

Maggiore coesione e separazione dei layer: la logica di persistenza e validazione rimane confinata nel package “facade/impl”, mentre i consumer vedono solo un’API di dominio.

Adesione al DIP: l’inversione di dipendenza rende il codice più testabile e manutenibile, poiché è possibile sostituire facilmente l’implementazione concreta con mock o alternative future.


